I"%&<p>Media queries are infants. The first Media Query public working draft was published in 2001, and they became a W3C recommendation after <a href="http://caniuse.com/#search=media%20queries">browser support</a> increased in 2012. 2012! <strong>That’s TWO years!</strong> Hard to believe, considering how essential they’ve become in our web workflows today. Media queries are most often used to build flexible <a href="http://mediaqueri.es/">web designs</a> which adapt to various browsers properties. Here are some <a href="https://developers.google.com/web/fundamentals/layouts/rwd-fundamentals/use-media-queries?hl=en">pointers</a> from the smart people at Google.</p>

<h3 id="media-query-capabilities">Media Query Capabilities</h3>

<p>If you’re familiar with building responsive websites, you’re probably familiar with something like: <code>@media screen and (max-width: 700px)</code>, but did you know that you can use media queries to specify how to handle <strong>paged braille printers</strong> or <strong>TVs</strong> or how to use <strong><a href="http://css-tricks.com/logic-in-media-queries/">logic</a></strong> in your media queries? Yeah, they’re pretty rad.</p>

<p>Here’s a list of current media types you can target:</p>

<ul>
  <li><code>all</code> — all the media types below</li>
  <li><code>braille</code>* — braille tactile feedback devices</li>
  <li><code>embossed</code>* — paged braille printers</li>
  <li><code>handheld</code>* — handheld devices like mobile phones</li>
  <li><code>print</code> — printed material</li>
  <li><code>projection</code>* — projected presentations</li>
  <li><code>screen</code> — color computer screens</li>
  <li><code>speech</code> — speech synthesizers</li>
  <li><code>tty</code>* — teletypes, terminals, and other devices with limited display capabilities</li>
  <li><code>tv</code>* — televisions and television like devices</li>
</ul>

<p><small>&amp;ast; = deprecated as media <strong>types</strong>, but can be used similarly as media <strong>features</strong> – read on)</small></p>

<p>And this is what you can specify (expressions) for each of those media types:</p>

<ul>
  <li><code>width</code> — width of the current window</li>
  <li><code>height</code> — height of the current window</li>
  <li><code>device-width</code> — width of the device</li>
  <li><code>device-height</code> — height of the device</li>
  <li><code>orientation</code> — either landscape or portrait</li>
  <li><code>aspect-ratio</code> — aspect ratio of the current window</li>
  <li><code>device-aspect-ratio</code> — aspect ratio of the device</li>
  <li><code>color</code> — number of color bits per color component</li>
  <li><code>color-index</code> — number of available colors on the device</li>
  <li><code>monochrome</code> — number of bits per pixel in a monochrome frame buffer</li>
  <li><code>resolution</code> — resolution of the device</li>
  <li><code>scan</code> — either progressive or interlace</li>
  <li><code>grid</code> — is the device grid-based?</li>
</ul>

<p>This list was stolen from <a href="http://cssmediaqueries.com/what-are-css-media-queries.html">here</a>, by the way.</p>

<h3 id="responsive-beyond-the-browser-size">Responsive Beyond the Browser Size</h3>

<p>Media queries are most often used for their screen size properties to allow for <strong>“Responsive Web Design”</strong>, or <strong>RWD</strong>. But viewing “responsive design” as just a means for detecting screen sizes and browsers is narrow-minded. Responsive principles go far past the browser and stretch into the real world — how can the products we design respond to a users location, or the weather, or the lighting? How can we really personalize experiences for our users?</p>

<p><a class="twitter-share quote left">
viewing “responsive design” as just a means for detecting screen sizes and browsers is narrow-minded
</a></p>

<p>Well media queries are helping us get one step closer! As devices are able to detect more, browsers are keeping up to date with these capabilities.
<br /><br /></p>

<h2 id="the-future-of-media-queries">The Future of Media Queries</h2>

<p>The <a href="http://dev.w3.org/csswg/mediaqueries-4/">Media Queries 4</a> spec brings insight to technological capabilities that are coming up soon (this is based on the Editor’s Draft, October 10, 2014).</p>

<h3 id="media-features-vs-types">Media Features vs Types</h3>
<p>One important distinction to note is that all of the <strong>media types</strong>* listed above will eventually become deprecated and replaced with more specific <strong><a href="http://dev.w3.org/csswg/mediaqueries-4/#mq-features">media features</a></strong></p>

<p>Media features are always wrapped in parentheses and combined with the <code>and</code> keyword rather than being separated with semicolons.</p>

<p>Here’s an example from the spec:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass">(color) and (min-width: 600px)</code></pre></figure>

<h3 id="media-light-level--dim--normal--washed">@media (light-level) : dim | normal | washed</h3>

<p>The <code>light-level</code> media feature is for detection <strong>ambient lighting</strong>. <em>(Ambient is such a fun word)</em>.</p>

<p>Values:</p>

<ul>
  <li><code>dim</code> — lighting in a dim environment (i.e. nighttime)</li>
  <li><code>normal</code> — lighting in the “ideal screen range”</li>
  <li><code>washed</code> — lighting in an overly bright environment (i.e. broad daylight)</li>
</ul>

<p>Here’s an example:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass">// change text coloring due to lighting for better legibility

@media (light-level: dim) {
  body { background: dimgrey;
         color: white;
    }
}

@media (light-level: washed) {
  body { background: white;
         color: black;
         font-size: 2em;
    }
}</code></pre></figure>

<h3 id="media-pointer--none--course--fine">@media (pointer) : none | course | fine</h3>

<p>The <code>pointer</code> media feature detects the <strong>presence and accuracy of a pointing device</strong>.</p>

<p>Values:</p>

<ul>
  <li><code>none</code> — there is no pointing device present (i.e. TV, printer)</li>
  <li><code>course</code> — the primary input mechanism is of limited accuracy (i.e. Nintendo Wii, Kinect, Google Glass)</li>
  <li><code>fine</code> — the primary input mechanism is an accurate pointing device (i.e. stylus, mouse, touchpad)</li>
</ul>

<p>Here’s an example:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass">// Make input larger for inaccurate pointing devices

@media (pointer:coarse) {
  input[type=&quot;text&quot;] {
    font-size: 3em;
    padding: .5em;
  }
}</code></pre></figure>

<h3 id="media-hover--none--on-demand--hover">@media (hover) : none | on-demand | hover</h3>

<p>The <code>hover</code> media feature detects the ability of the primary pointing mechanism to hover over elements.</p>

<p>Values:</p>

<ul>
  <li><code>none</code> — there primary pointing mechanism can’t hover</li>
  <li><code>on-demand</code> — the user can hover but it requires significant action (i.e. touch screens)</li>
  <li><code>fine</code> — the primary pointing system can easily hover</li>
</ul>

<p><small> &amp;ast; If different input devices have different characteristics, there are also <code>any-pointer</code> and <code>any-hover</code> media features </small></p>

<p>Here’s an example:</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass">//If hover is difficult, display the menu differently

@media (hover:none) and (hover:on-demand) {
  .menu {
    display: block;
    position absolute;
    ...
  }
}</code></pre></figure>

<h3 id="media-update-frequency--none--slow--normal">@media (update-frequency) : none | slow | normal</h3>

<p>The <code>update-frequency</code> media feature is used to query the ability of the output device to modify the appearance of content once it has been rendered.</p>

<p>Values:</p>

<ul>
  <li><code>none</code> — once rendered, the layout will not update (i.e. printed materials)</li>
  <li><code>slow</code> — the layout may change dynamically but not smoothly (i.e. e-ink displays)</li>
  <li><code>normal</code> — the output device is not constrained</li>
</ul>

<p>Here’s an example (stolen right from the spec):</p>

<figure class="highlight"><pre><code class="language-sass" data-lang="sass">//If a page styles its links to only add underlines on hover,
// it may want to always display underlines when printed:

a {
  text-decoration: none;
}

a:hover, a:focus {
  text-decoration: underline;
}

@media (update-frequency: none) {
  a {
    text-decoration: underline;
    }
}</code></pre></figure>

<h3 id="media-scripting--none--initial-only--enabled">@media (scripting) : none | initial-only | enabled</h3>

<p>The <code>scripting</code> media feature detects <strong>whether or not Javascript is enabled</strong> in the browser.</p>

<p>Values:</p>

<ul>
  <li><code>none</code> — scripting is not supported by the user agent, or innactive</li>
  <li><code>enabled</code> — scripting is supported and active</li>
  <li><code>initial-only</code> — scripting is supported on initial page load, but not afterwards</li>
</ul>

<p>This section also borrowed heavily from the these <a href="http://www.slideshare.net/yiibu/the-future-of-mediaqueries">slides</a>, which break down the information from the spec really well.</p>

<p>Remember, it has only been 2 years since the general adoption of media queries and responsive web design. If this is just the beginning, then where are they heading next?</p>
:ET