I"g<p>It’s been on my to-do list for two weeks now — adding a <code>:visited</code> state to my blog posts. I was inspired after reading <a href="http://joelcalifa.com/blog/revisiting-visited/">this</a> blog post by <a href="http://twitter.com/notdetails">Joel Califa</a>, and thought “Heck yeah. That’s a great idea. I can use it on my blog to represent links that haven’t been read yet.” But like most things on the Internet, it looked a lot cleaner from a distance.</p>

<h2 id="what-is-visited">What is :visited?</h2>

<p><code>:visited</code> is a pseudo-class that is used to style links which have already been accessed in the browser of a user. Basically when you can tell if you have already been to a link or haven’t yet (Joel’s post goes over this really nicely – I’d highly recommend checking it out). <img src="../images/posts/visited/home.png" alt="example image" style="max-width: 480px; width: 100%;" class="right" /> In the early days of the Internet, stylig visited links was extremely prevalant, and a great way to understand context of place in a digital space. We seem to have lost that practice, and I rarely see it in action these days.</p>

<h2 id="limitations">Limitations</h2>

<p>It all started fine and dandy. I applied <code>:visited</code> to the links on the home page and then accessed the child <code>h2</code> within them to change it’s text color. This was a test. To avoid annoying my audience, what I really wanted was <code>:unvisited</code>, or to display a strikeout, or checkbox, or an <em>“Unread!”</em> badge. I could do any of those with the <code>:after</code> psuedo element. Well upon trying it, everything broke. So I did some <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:visited">research</a> and discovered a few fun facts from reading the fine print:</p>

<blockquote>
  <p>“For privacy reasons, browsers strictly limit the styles you can apply using an element selected by this pseudo-class: only color, background-color, border-color (and its sub-properties), outline-color, column-rule-color, and the color parts of fill and stroke.”</p>
</blockquote>

<p>So you can only change color? Well, being the stubborn girl I am, I knew I could work around this. I first tried to inject style with JavaScript. That was fine – but it didn’t overpower the style logic embedded in browsers. The method <code>getComputedStyle()</code> is disabled for this pseudo class. According to the official Mozilla developer documentation: <strong>“the method getComputedStyle will lie.”</strong> Nice.</p>

<p>Then, I thought: maybe I can use the <code>color: transparent</code> to essentially hide the pseudo element content and only show the color when I want to apply them! I’m changing only the color, right? But when I did this, <em>all</em> of the pseudo elements (not just the visited ones) disappeared… <em>Wat?</em> … It turns out that the <code>:visited</code> tag will always pull its parent’s alpha channel. So, even trying <code>rgba(0,0,0,0)</code> will make everything disappear.</p>

<h2 id="why-the-limitations">Why the Limitations?</h2>

<p>So what’s up with this strict limitation anyway? Well, the way that <code>:visited</code> works is by walking through the user’s history to figure out what sites the they’ve visited. This means that a lot of information can be accessed about that user, and their identity could be inferred. In 2010, a lot of changes were made to limit access to this type of information. Under certain circumstances, the browser is more likely to <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Privacy_and_the_:visited_selector">lie</a> and mark a link as unvisited.</p>

<h2 id="its-not-over-till-i-win">It’s Not Over Till I Win</h2>

<p>It ended up being a pretty simple solution. To get the effect I wanted, I first, gave every element with a blog title (<code>h2</code> in this case) an <code>:after</code> pseudo-element and styled it to my preferences:</p>

<pre><code class="language-scss">h2 {
  color: blue;

  &amp;:after {
    content: '(unread!)';
    color: hotpink;
    display: inline-block;
    font-size: .6em;
    margin-left: .5em;
    vertical-align: middle;
  }
}
</code></pre>

<p>Then I had to apply the <code>:visited</code> pseudo class to all of the links in the list and target a child element <code>h2:after</code> to effectively <em>“hide”</em> it. I’m “hiding” it here by giving it the same color as the background (white). If you’re not familiar with the power of the Sass ampersand, I’d recommend checking out <a href="http://una.im//2014/03/06/sass-snippets-the-almighty-ampersand.html">this post</a>.</p>

<pre><code class="language-scss">a {
  display: block;
  text-decoration: none;

  &amp;:visited h2:after {
    color: white;
  }
}
</code></pre>

<p>Awesome! So we’re almost there. <code>:visited</code> is working. I’ve gotten relatively “hidden” badges. But then there’s this hover… I’m applying a lightgrey background to each list-item when hovering over them, and I need to make sure I don’t give away my pseudo-element secrets when hovering. So I simply just need to compensate:</p>

<pre><code class="language-scss">// set global transition:
%transition-duration {
  transition-duration: .5s;
}

li {
  // applying uniform transition:
  @extend %transition-duration;

  // this is where I'm apply hover style:
  &amp;:hover {
    background-color: lightgrey;

    // within the hover state, I'm also transitioning the h2:after color to match the background transition
    a:visited h2:after {
      color: lightgrey;
    }
  }
}

// return to the header to give it an identical transition:
h2 {
  color: blue;

  &amp;:after {
    // applying uniform transition:
    @extend %transition-duration;
    ...
  }
}
</code></pre>

<h2 id="what-about-accessibility">What About Accessibility?</h2>

<p>You’re right. Since some screen readers do read pseudo elements, we’ll want to avoid hearing “unread” after every blog post title. That would be inaccurate. Also, <strong>fun fact:</strong> screen readers typically do this work for us. They note if a link has been visited or not right away before reading the link text.</p>

<p>To mitigate this, we can create a blank element as a placeholder next to the title with attribute <code>aria-hidden="true"</code> so that the screen reader doesn’t try to read it. I’m using a <code>span</code> tag next to the <code>h2</code>. The content of the header will still be read normally, but anything inside of <code>span</code> is ignored. A simplified example in broken <a href="https://docs.shopify.com/themes/liquid-documentation/basics">Liquid</a>:</p>

<pre><code class="language-html">{ % for post in posts % }
  &lt;li&gt;
    &lt;a href="{ { post.url | prepend: site.baseurl } }"&gt;
      &lt;h2 aria-label="{ { post.title } }"&gt;
        { { post.title } }
      &lt;/h2&gt;
      &lt;span aria-hidden="true"&gt;&lt;/span&gt;
    &lt;/a&gt;
  &lt;/li&gt;
{ % endfor % }
</code></pre>

<p>This will cause a need to make minor changes things in the CSS now. But a quick way to make that change would simply be to swap out <code>h2</code> with <code>span</code>. Because we’re introducing a new element here, you don’t have to rely on pseudo-elements, and can even write the content or apply the visuals directly inside of the span tag: <code>&lt;span aria-hidden="true"&gt;(Unread!)&lt;/span&gt;</code>.</p>

<p><img src="../images/posts/visited/list.png" alt="archive list" style="max-width: 460px; width: 100%;" class="left" /></p>

<p>The downside is that none of the posts will be denoted as “unread,” but since it’s an enhancement anyway, ignoring the tag seems to be a better option than falsely reading it with every single header (which, as pointed out earlier, is redundant anyway).</p>

<p>So check out the <a href="http://una.im/archive/">archive</a> and you can see what you’ve missed out on!</p>

<div style="clear: both;"></div>

:ET