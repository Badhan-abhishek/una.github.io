---
layout: post
title: "If You Know Sass, You know ES2015"
permalink: /svg-icons
date: '2016-02-23'
comments: true
tags:
- sass
- js
- javascript
- es2015
- trendy
- comparisions
- code
- basics
- intro
header-bg: "https://i.ytimg.com/vi/iRMXbJKe8EA/maxresdefault.jpg"
subtitle: "If you know some Sass, you're probably a lot further than you think to understanding and diving into the world of modern JavaScript. This post showcases some of the similarities."
---

...well not exactly, but there are a lot of similarities. While learning about the ES2015 (formerly known as ES6), the [latest ECMAScript specification](http://www.ecma-international.org/ecma-262/6.0/), I came upon a few features which were new to JavaScript, that I immediately recognized from Sass. And I kept seeing more and more pop up. So what I'm trying to say here is, a lot of the concepts transfer. If you know some Sass, you're probably a lot further than you think to diving into modern JavaScript.

## Sass and ES2015

The [Sass language](http://sass-lang.com) was written very intentionally. It was originally released in 2006, and being written in Ruby, also imitated the Ruby syntax. Semicolons and additions to make Sass feel more like (and be compatible with) CSS3 emerged in [version 3.0.0](http://sass-lang.com/documentation/file.SASS_CHANGELOG.html#scss_sassy_css), and a lot of core Sass functionality which made it more extensible (SassScript) continued to make it a robust programming language, now compatible with CSS.



<figure class="left">
  <blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">The more I learn about ES6 features, the more it looks like <a href="https://twitter.com/SassCSS">@SassCSS</a> to me.<br><br>(i.e. maps, classes, interpolation, constructors)<br><br>Am I crazy?</p>&mdash; Una Kravets (@Una) <a href="https://twitter.com/Una/status/634051950552571905">August 19, 2015</a></blockquote>
  <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</figure>

There's a lot of thought behind every Sass language decision, with a big emphasis on clarity over customization (a big reason why Sass wouldn't allow for custom properties like [PostCSS](http://postcss.org/) does). With the new [ECMAScript 2015 spec](http://www.ecma-international.org/ecma-262/6.0/) that was released in June of last year, there were a lot of new featured added to the JavaScript language that too made it more clear and less convoluted to use.

While most browsers still don't yet [support](https://kangax.github.io/compat-table/es6/) ES2015, you can use a transpiler, like [Babel](https://babeljs.io/) to convert the code into compatible ES5. The precompile step (yes, I know they're not exactly the same) is only the beginning of the similarities of the two languages. There are a lot of Sass features now implemented in ES2015 that you might not realize you have familiarity with as a Sass developer, and visa versa about Sass if you're a JavaScript developer. Let's take a look:

- maps, classes, interpolation, constructors
- template strings (string interpolation)
- argument defaults
- rest parameters (arglist) (using spread operator in function definitions, which works differently than when used)
  --> must be the last
- for (___ of ___) loop (like Sass' for ___ in ____) -- note: this is different than JavaScript's [forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) functionality

## ES2015 Maps

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
- http://www.ecma-international.org/ecma-262/6.0/#sec-map-constructor

## ES2015 Template String Interpolation

This ES2015 feature is the first time I realized how similar the two specs were. The string interpolation is almost identical (and it made me smile a lot). Basically, ES2015 introduced an *awesome* new inherent string templating feature using backticks.

- no longer need to use an external templating engine
- creates uniformity among code bases
- show example of both JS and Sass
- really easy to use, no more "hello " + var + "!" <-- which is very cumbersome.
- use variables directly inside of the statement
- no more `\n` for new lines (respects whitespace)

<div class="half--left highlight">
<pre>
<code class="language-js hljs">//.js
//hello
</code></pre>
</div>

<div class="half--right highlight">
<pre><code class="language-scss hljs ">//.scss
//lah
</code></pre>
</div>

## ES2015 Rest Parameters

Rest parameters in ES2015 are a lot like the arglist argument types in Sass. Rest parameters (like arglist) must be the last value of a series of arguments when instantiating a function.

<div class="half--left highlight">
<pre>
<code class="language-js hljs">//.js
//hello
</code></pre>
</div>

<div class="half--right highlight">
<pre><code class="language-scss hljs ">//.scss
//lah
</code></pre>
</div>

## ES2015 "for-of" Loop

The [new looping](https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/) structure for arrays in ES2015 is very similar to the looping structure in Sass. ES2015 introduced the *for-of* loop. You may be wondering, *how does this differ from for-in?* First of all, it refers to the array **value**, not the array **index**.

Secondly, one of the problems with *for-in* is that you can't break out of or return from a *for-in* loop. This is because the *for–in* loop lets you for looping over object properties, while the more flexible *for–of* loop lets you loop over data—like the values in an array.

With Sass, the looping of anything works the same way as `for-of`, whether that be a map or a list, or a list of lists.

<div class="half--left highlight">
<pre>
<code class="language-js hljs">//.js

let colorArray = ["red", "yellow", "green"];

for (let color of colorArray) {
  console.log(color);
}
</code></pre>
</div>

<div class="half--right highlight">
<pre><code class="language-scss hljs ">//.scss

$colorList: "red", "yellow", "green";

@each $color in $colorList {
  @debug $color;
}
</code></pre>
</div>

<div class="clearfix"></div>

If I used `for (let color in colorArray)` (**in** instead of **of**) the result would be *1, 2, 3* instead of *red, yellow, green*. In Sass, a `@debug` statement (shown above for brevity), is most similar to `console.log`, though, you could also `@return` values this way. However, these loops are most commonly used for generating multiple classes and styles. For example, if instead of `@return $color;` I had `.#{$color} { color: #{$color}}` (see string templating above) it would generate 3 classes (red, yellow, and green) which each set the color property to match their respective names.